/******************************************************************************
 * This file was generated by langium-cli 4.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

/** Contains the reachable terminals & keywords and all available types of the 'Arithmetics' language. */
export namespace Arithmetics {

    export const Terminals = {
        WS: /\s+/,
        ID: /[_a-zA-Z][\w_]*/,
        NUMBER: /[0-9]+(\.[0-9]*)?/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
    };

    export type TerminalNames = keyof typeof Terminals;

    export type KeywordNames =
        | "%"
        | "("
        | ")"
        | "*"
        | "+"
        | ","
        | "-"
        | "/"
        | ":"
        | ";"
        | "^"
        | "def"
        | "module";

    export type TokenNames = TerminalNames | KeywordNames;

    export type AstType = {
        AbstractDefinition: AbstractDefinition
        BinaryExpression: BinaryExpression
        DeclaredParameter: DeclaredParameter
        Definition: Definition
        Evaluation: Evaluation
        Expression: Expression
        FunctionCall: FunctionCall
        Module: Module
        NumberLiteral: NumberLiteral
        Statement: Statement
    }

}

/** Contains the reachable terminals & keywords and all available types of the 'DomainModel' language. */
export namespace DomainModel {

    export const Terminals = {
        WS: /\s+/,
        ID: /[_a-zA-Z][\w_]*/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
    };

    export type TerminalNames = keyof typeof Terminals;

    export type KeywordNames =
        | "."
        | ":"
        | "datatype"
        | "entity"
        | "extends"
        | "many"
        | "package"
        | "{"
        | "}";

    export type TokenNames = TerminalNames | KeywordNames;

    export type AstType = {
        AbstractElement: AbstractElement
        DataType: DataType
        Domainmodel: Domainmodel
        Entity: Entity
        Feature: Feature
        PackageDeclaration: PackageDeclaration
        Type: Type
    }

}

/** Contains the reachable terminals & keywords and all available types of the 'Requirements' language. */
export namespace Requirements {

    export const Terminals = {
        WS: /\s+/,
        ID: /[_a-zA-Z][\w_]*/,
        STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
    };

    export type TerminalNames = keyof typeof Terminals;

    export type KeywordNames =
        | ","
        | ":"
        | "applicable"
        | "contact"
        | "environment"
        | "for"
        | "req";

    export type TokenNames = TerminalNames | KeywordNames;

    export type AstType = {
        Contact: Contact
        Environment: Environment
        Requirement: Requirement
        RequirementModel: RequirementModel
    }

}

/** Contains the reachable terminals & keywords and all available types of the 'StatemachineModel' language. */
export namespace StatemachineModel {

    export const Terminals = {
        WS: /\s+/,
        ID: /[_a-zA-Z][\w_]*/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
    };

    export type TerminalNames = keyof typeof Terminals;

    export type KeywordNames =
        | "=>"
        | "actions"
        | "commands"
        | "end"
        | "events"
        | "initialState"
        | "state"
        | "statemachine"
        | "{"
        | "}";

    export type TokenNames = TerminalNames | KeywordNames;

    export type AstType = {
        Command: Command
        Event: Event
        State: State
        Statemachine: Statemachine
        Transition: Transition
    }

}

/** Contains the reachable terminals & keywords and all available types of the 'Tests' language. */
export namespace Tests {

    export const Terminals = {
        WS: /\s+/,
        ID: /[_a-zA-Z][\w_]*/,
        STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
    };

    export type TerminalNames = keyof typeof Terminals;

    export type KeywordNames =
        | ","
        | ":"
        | "="
        | "applicable"
        | "contact"
        | "for"
        | "testFile"
        | "tests"
        | "tst";

    export type TokenNames = TerminalNames | KeywordNames;

    export type AstType = {
        Contact: Contact
        Environment: Environment
        Requirement: Requirement
        RequirementModel: RequirementModel
        Test: Test
        TestModel: TestModel
    }

}


// the terminals, keywords and types of the whole 'Domain' project

export const DomainTerminals = {
    ...Arithmetics.Terminals,
    ...DomainModel.Terminals,
    ...Requirements.Terminals,
    ...StatemachineModel.Terminals,
    ...Tests.Terminals,
};

export type DomainTerminalNames = keyof typeof DomainTerminals;

export type DomainKeywordNames = Arithmetics.KeywordNames | DomainModel.KeywordNames | Requirements.KeywordNames | StatemachineModel.KeywordNames | Tests.KeywordNames;

export type DomainTokenNames = DomainTerminalNames | DomainKeywordNames;

export type DomainAstType = Arithmetics.AstType & DomainModel.AstType & Requirements.AstType & StatemachineModel.AstType & Tests.AstType


// all type definitions of the the whole 'Domain' project

export type AbstractDefinition = DeclaredParameter | Definition;

export const AbstractDefinition = {
    $type: 'AbstractDefinition'
} as const;

export function isAbstractDefinition(item: unknown): item is AbstractDefinition {
    return reflection.isInstance(item, AbstractDefinition.$type);
}

export type AbstractElement = PackageDeclaration | Type;

export const AbstractElement = {
    $type: 'AbstractElement'
} as const;

export function isAbstractElement(item: unknown): item is AbstractElement {
    return reflection.isInstance(item, AbstractElement.$type);
}

export interface BinaryExpression extends langium.AstNode {
    readonly $container: BinaryExpression | Definition | Evaluation | FunctionCall;
    readonly $type: 'BinaryExpression';
    left: Expression;
    operator: '%' | '*' | '+' | '-' | '/' | '^';
    right: Expression;
}

export const BinaryExpression = {
    $type: 'BinaryExpression',
    left: 'left',
    operator: 'operator',
    right: 'right'
} as const;

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression.$type);
}

export interface Command extends langium.AstNode {
    readonly $container: Statemachine;
    readonly $type: 'Command';
    name: string;
}

export const Command = {
    $type: 'Command',
    name: 'name'
} as const;

export function isCommand(item: unknown): item is Command {
    return reflection.isInstance(item, Command.$type);
}

export interface Contact extends langium.AstNode {
    readonly $container: RequirementModel | TestModel;
    readonly $type: 'Contact';
    user_name: string;
}

export const Contact = {
    $type: 'Contact',
    user_name: 'user_name'
} as const;

export function isContact(item: unknown): item is Contact {
    return reflection.isInstance(item, Contact.$type);
}

export interface DataType extends langium.AstNode {
    readonly $container: Domainmodel | PackageDeclaration;
    readonly $type: 'DataType';
    name: string;
}

export const DataType = {
    $type: 'DataType',
    name: 'name'
} as const;

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType.$type);
}

export interface DeclaredParameter extends langium.AstNode {
    readonly $container: Definition;
    readonly $type: 'DeclaredParameter';
    name: string;
}

export const DeclaredParameter = {
    $type: 'DeclaredParameter',
    name: 'name'
} as const;

export function isDeclaredParameter(item: unknown): item is DeclaredParameter {
    return reflection.isInstance(item, DeclaredParameter.$type);
}

export interface Definition extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Definition';
    args: Array<DeclaredParameter>;
    expr: Expression;
    name: string;
}

export const Definition = {
    $type: 'Definition',
    args: 'args',
    expr: 'expr',
    name: 'name'
} as const;

export function isDefinition(item: unknown): item is Definition {
    return reflection.isInstance(item, Definition.$type);
}

export interface Domainmodel extends langium.AstNode {
    readonly $type: 'Domainmodel';
    elements: Array<AbstractElement>;
}

export const Domainmodel = {
    $type: 'Domainmodel',
    elements: 'elements'
} as const;

export function isDomainmodel(item: unknown): item is Domainmodel {
    return reflection.isInstance(item, Domainmodel.$type);
}

export interface Entity extends langium.AstNode {
    readonly $container: Domainmodel | PackageDeclaration;
    readonly $type: 'Entity';
    features: Array<Feature>;
    name: string;
    superType?: langium.MultiReference<Entity>;
}

export const Entity = {
    $type: 'Entity',
    features: 'features',
    name: 'name',
    superType: 'superType'
} as const;

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity.$type);
}

export interface Environment extends langium.AstNode {
    readonly $container: RequirementModel;
    readonly $type: 'Environment';
    description: string;
    name: string;
}

export const Environment = {
    $type: 'Environment',
    description: 'description',
    name: 'name'
} as const;

export function isEnvironment(item: unknown): item is Environment {
    return reflection.isInstance(item, Environment.$type);
}

export interface Evaluation extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Evaluation';
    expression: Expression;
}

export const Evaluation = {
    $type: 'Evaluation',
    expression: 'expression'
} as const;

export function isEvaluation(item: unknown): item is Evaluation {
    return reflection.isInstance(item, Evaluation.$type);
}

/** An event is the trigger for a transition */
export interface Event extends langium.AstNode {
    readonly $container: Statemachine;
    readonly $type: 'Event';
    name: string;
}

export const Event = {
    $type: 'Event',
    name: 'name'
} as const;

export function isEvent(item: unknown): item is Event {
    return reflection.isInstance(item, Event.$type);
}

export type Expression = BinaryExpression | FunctionCall | NumberLiteral;

export const Expression = {
    $type: 'Expression'
} as const;

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression.$type);
}

export interface Feature extends langium.AstNode {
    readonly $container: Entity;
    readonly $type: 'Feature';
    many: boolean;
    name: string;
    type: langium.Reference<Type>;
}

export const Feature = {
    $type: 'Feature',
    many: 'many',
    name: 'name',
    type: 'type'
} as const;

export function isFeature(item: unknown): item is Feature {
    return reflection.isInstance(item, Feature.$type);
}

export interface FunctionCall extends langium.AstNode {
    readonly $container: BinaryExpression | Definition | Evaluation | FunctionCall;
    readonly $type: 'FunctionCall';
    args: Array<Expression>;
    func: langium.Reference<AbstractDefinition>;
}

export const FunctionCall = {
    $type: 'FunctionCall',
    args: 'args',
    func: 'func'
} as const;

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall.$type);
}

export interface Module extends langium.AstNode {
    readonly $type: 'Module';
    name: string;
    statements: Array<Statement>;
}

export const Module = {
    $type: 'Module',
    name: 'name',
    statements: 'statements'
} as const;

export function isModule(item: unknown): item is Module {
    return reflection.isInstance(item, Module.$type);
}

export interface NumberLiteral extends langium.AstNode {
    readonly $container: BinaryExpression | Definition | Evaluation | FunctionCall;
    readonly $type: 'NumberLiteral';
    value: number;
}

export const NumberLiteral = {
    $type: 'NumberLiteral',
    value: 'value'
} as const;

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral.$type);
}

export interface PackageDeclaration extends langium.AstNode {
    readonly $container: Domainmodel | PackageDeclaration;
    readonly $type: 'PackageDeclaration';
    elements: Array<AbstractElement>;
    name: QualifiedName;
}

export const PackageDeclaration = {
    $type: 'PackageDeclaration',
    elements: 'elements',
    name: 'name'
} as const;

export function isPackageDeclaration(item: unknown): item is PackageDeclaration {
    return reflection.isInstance(item, PackageDeclaration.$type);
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return typeof item === 'string';
}

export interface Requirement extends langium.AstNode {
    readonly $container: RequirementModel;
    readonly $type: 'Requirement';
    environments: Array<langium.Reference<Environment>>;
    name: string;
    text: string;
}

export const Requirement = {
    $type: 'Requirement',
    environments: 'environments',
    name: 'name',
    text: 'text'
} as const;

export function isRequirement(item: unknown): item is Requirement {
    return reflection.isInstance(item, Requirement.$type);
}

export interface RequirementModel extends langium.AstNode {
    readonly $type: 'RequirementModel';
    contact?: Contact;
    environments: Array<Environment>;
    requirements: Array<Requirement>;
}

export const RequirementModel = {
    $type: 'RequirementModel',
    contact: 'contact',
    environments: 'environments',
    requirements: 'requirements'
} as const;

export function isRequirementModel(item: unknown): item is RequirementModel {
    return reflection.isInstance(item, RequirementModel.$type);
}

/** A description of the status of a system */
export interface State extends langium.AstNode {
    readonly $container: Statemachine;
    readonly $type: 'State';
    actions: Array<langium.Reference<Command>>;
    name: string;
    /** The transitions to other states that can take place from the current one */
    transitions: Array<Transition>;
}

export const State = {
    $type: 'State',
    actions: 'actions',
    name: 'name',
    transitions: 'transitions'
} as const;

export function isState(item: unknown): item is State {
    return reflection.isInstance(item, State.$type);
}

/** A textual representation of a state machine */
export interface Statemachine extends langium.AstNode {
    readonly $type: 'Statemachine';
    commands: Array<Command>;
    /** The list of recognized event names */
    events: Array<Event>;
    /** The starting state for the machine */
    init: langium.Reference<State>;
    /** The name of the machine */
    name: string;
    /** Definitions of available states */
    states: Array<State>;
}

export const Statemachine = {
    $type: 'Statemachine',
    commands: 'commands',
    events: 'events',
    init: 'init',
    name: 'name',
    states: 'states'
} as const;

export function isStatemachine(item: unknown): item is Statemachine {
    return reflection.isInstance(item, Statemachine.$type);
}

export type Statement = Definition | Evaluation;

export const Statement = {
    $type: 'Statement'
} as const;

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement.$type);
}

export interface Test extends langium.AstNode {
    readonly $container: TestModel;
    readonly $type: 'Test';
    environments: Array<langium.Reference<Environment>>;
    name: string;
    requirements: Array<langium.Reference<Requirement>>;
    testFile?: string;
}

export const Test = {
    $type: 'Test',
    environments: 'environments',
    name: 'name',
    requirements: 'requirements',
    testFile: 'testFile'
} as const;

export function isTest(item: unknown): item is Test {
    return reflection.isInstance(item, Test.$type);
}

export interface TestModel extends langium.AstNode {
    readonly $type: 'TestModel';
    contact?: Contact;
    tests: Array<Test>;
}

export const TestModel = {
    $type: 'TestModel',
    contact: 'contact',
    tests: 'tests'
} as const;

export function isTestModel(item: unknown): item is TestModel {
    return reflection.isInstance(item, TestModel.$type);
}

/** A change from one state to another */
export interface Transition extends langium.AstNode {
    readonly $container: State;
    readonly $type: 'Transition';
    /** The event triggering the transition */
    event: langium.Reference<Event>;
    /** The target state */
    state: langium.Reference<State>;
}

export const Transition = {
    $type: 'Transition',
    event: 'event',
    state: 'state'
} as const;

export function isTransition(item: unknown): item is Transition {
    return reflection.isInstance(item, Transition.$type);
}

export type Type = DataType | Entity;

export const Type = {
    $type: 'Type'
} as const;

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type.$type);
}

export class DomainAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        AbstractDefinition: {
            name: AbstractDefinition.$type,
            properties: {
            },
            superTypes: []
        },
        AbstractElement: {
            name: AbstractElement.$type,
            properties: {
            },
            superTypes: []
        },
        BinaryExpression: {
            name: BinaryExpression.$type,
            properties: {
                left: {
                    name: BinaryExpression.left
                },
                operator: {
                    name: BinaryExpression.operator
                },
                right: {
                    name: BinaryExpression.right
                }
            },
            superTypes: [Expression.$type]
        },
        Command: {
            name: Command.$type,
            properties: {
                name: {
                    name: Command.name
                }
            },
            superTypes: []
        },
        Contact: {
            name: Contact.$type,
            properties: {
                user_name: {
                    name: Contact.user_name
                }
            },
            superTypes: []
        },
        DataType: {
            name: DataType.$type,
            properties: {
                name: {
                    name: DataType.name
                }
            },
            superTypes: [Type.$type]
        },
        DeclaredParameter: {
            name: DeclaredParameter.$type,
            properties: {
                name: {
                    name: DeclaredParameter.name
                }
            },
            superTypes: [AbstractDefinition.$type]
        },
        Definition: {
            name: Definition.$type,
            properties: {
                args: {
                    name: Definition.args,
                    defaultValue: []
                },
                expr: {
                    name: Definition.expr
                },
                name: {
                    name: Definition.name
                }
            },
            superTypes: [AbstractDefinition.$type, Statement.$type]
        },
        Domainmodel: {
            name: Domainmodel.$type,
            properties: {
                elements: {
                    name: Domainmodel.elements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Entity: {
            name: Entity.$type,
            properties: {
                features: {
                    name: Entity.features,
                    defaultValue: []
                },
                name: {
                    name: Entity.name
                },
                superType: {
                    name: Entity.superType,
                    referenceType: Entity.$type
                }
            },
            superTypes: [Type.$type]
        },
        Environment: {
            name: Environment.$type,
            properties: {
                description: {
                    name: Environment.description
                },
                name: {
                    name: Environment.name
                }
            },
            superTypes: []
        },
        Evaluation: {
            name: Evaluation.$type,
            properties: {
                expression: {
                    name: Evaluation.expression
                }
            },
            superTypes: [Statement.$type]
        },
        Event: {
            name: Event.$type,
            properties: {
                name: {
                    name: Event.name
                }
            },
            superTypes: []
        },
        Expression: {
            name: Expression.$type,
            properties: {
            },
            superTypes: []
        },
        Feature: {
            name: Feature.$type,
            properties: {
                many: {
                    name: Feature.many,
                    defaultValue: false
                },
                name: {
                    name: Feature.name
                },
                type: {
                    name: Feature.type,
                    referenceType: Type.$type
                }
            },
            superTypes: []
        },
        FunctionCall: {
            name: FunctionCall.$type,
            properties: {
                args: {
                    name: FunctionCall.args,
                    defaultValue: []
                },
                func: {
                    name: FunctionCall.func,
                    referenceType: AbstractDefinition.$type
                }
            },
            superTypes: [Expression.$type]
        },
        Module: {
            name: Module.$type,
            properties: {
                name: {
                    name: Module.name
                },
                statements: {
                    name: Module.statements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        NumberLiteral: {
            name: NumberLiteral.$type,
            properties: {
                value: {
                    name: NumberLiteral.value
                }
            },
            superTypes: [Expression.$type]
        },
        PackageDeclaration: {
            name: PackageDeclaration.$type,
            properties: {
                elements: {
                    name: PackageDeclaration.elements,
                    defaultValue: []
                },
                name: {
                    name: PackageDeclaration.name
                }
            },
            superTypes: [AbstractElement.$type]
        },
        Requirement: {
            name: Requirement.$type,
            properties: {
                environments: {
                    name: Requirement.environments,
                    defaultValue: [],
                    referenceType: Environment.$type
                },
                name: {
                    name: Requirement.name
                },
                text: {
                    name: Requirement.text
                }
            },
            superTypes: []
        },
        RequirementModel: {
            name: RequirementModel.$type,
            properties: {
                contact: {
                    name: RequirementModel.contact
                },
                environments: {
                    name: RequirementModel.environments,
                    defaultValue: []
                },
                requirements: {
                    name: RequirementModel.requirements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        State: {
            name: State.$type,
            properties: {
                actions: {
                    name: State.actions,
                    defaultValue: [],
                    referenceType: Command.$type
                },
                name: {
                    name: State.name
                },
                transitions: {
                    name: State.transitions,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Statemachine: {
            name: Statemachine.$type,
            properties: {
                commands: {
                    name: Statemachine.commands,
                    defaultValue: []
                },
                events: {
                    name: Statemachine.events,
                    defaultValue: []
                },
                init: {
                    name: Statemachine.init,
                    referenceType: State.$type
                },
                name: {
                    name: Statemachine.name
                },
                states: {
                    name: Statemachine.states,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Statement: {
            name: Statement.$type,
            properties: {
            },
            superTypes: []
        },
        Test: {
            name: Test.$type,
            properties: {
                environments: {
                    name: Test.environments,
                    defaultValue: [],
                    referenceType: Environment.$type
                },
                name: {
                    name: Test.name
                },
                requirements: {
                    name: Test.requirements,
                    defaultValue: [],
                    referenceType: Requirement.$type
                },
                testFile: {
                    name: Test.testFile
                }
            },
            superTypes: []
        },
        TestModel: {
            name: TestModel.$type,
            properties: {
                contact: {
                    name: TestModel.contact
                },
                tests: {
                    name: TestModel.tests,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Transition: {
            name: Transition.$type,
            properties: {
                event: {
                    name: Transition.event,
                    referenceType: Event.$type
                },
                state: {
                    name: Transition.state,
                    referenceType: State.$type
                }
            },
            superTypes: []
        },
        Type: {
            name: Type.$type,
            properties: {
            },
            superTypes: [AbstractElement.$type]
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new DomainAstReflection();
